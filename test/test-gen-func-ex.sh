#!/bin/bash

# Copyright (C) 2016  Stefan Vargyas
# 
# This file is part of German-Num.
# 
# German-Num is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# German-Num is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with German-Num.  If not, see <http://www.gnu.org/licenses/>.

#
# File generated by a command like:
# $ gen-test -T gen-func-ex
#

[[ "$1" =~ ^-u[0-9]+$ ]] &&
u="${1:2}" ||
u=""

diff -u$u -L gen-func-ex.old <(echo \
'$ test -x ./calc
$ shopt -s extglob
$ . ../src/commands.sh
$ gen-func() { printf '\''%s\n'\'' "$@"|calc-gen-func; }
$ gen-func a
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a
	if (*n ++ == '\''a'\'') {
		r = n;
		t = token_t::a;
		return true;
	}
	return false;
}
$ gen-func a a
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a
	if (*n ++ == '\''a'\'') {
		r = n;
		t = token_t::a;
		return true;
	}
	return false;
}
$ gen-func a aa b
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a[a]|b
	switch (*n ++) {
	case '\''a'\'': {
		const char* p = n;
		if (*n ++ == '\''a'\'') {
			r = n;
			t = token_t::aa;
			return true;
		}
		else {
			r = p;
			t = token_t::a;
			return true;
		}
	}
	case '\''b'\'':
		r = n;
		t = token_t::b;
		return true;
	}
	return false;
}
$ gen-func a ab
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a[b]
	if (*n ++ == '\''a'\'') {
		const char* p = n;
		if (*n ++ == '\''b'\'') {
			r = n;
			t = token_t::ab;
			return true;
		}
		else {
			r = p;
			t = token_t::a;
			return true;
		}
	}
	return false;
}
$ gen-func a ab abc
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a[b[c]]
	if (*n ++ == '\''a'\'') {
		const char* p = n;
		if (*n ++ == '\''b'\'') {
			const char* p = n;
			if (*n ++ == '\''c'\'') {
				r = n;
				t = token_t::abc;
				return true;
			}
			else {
				r = p;
				t = token_t::ab;
				return true;
			}
		}
		else {
			r = p;
			t = token_t::a;
			return true;
		}
	}
	return false;
}
$ gen-func a ab abc abcd
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a[b[c[d]]]
	if (*n ++ == '\''a'\'') {
		const char* p = n;
		if (*n ++ == '\''b'\'') {
			const char* p = n;
			if (*n ++ == '\''c'\'') {
				const char* p = n;
				if (*n ++ == '\''d'\'') {
					r = n;
					t = token_t::abcd;
					return true;
				}
				else {
					r = p;
					t = token_t::abc;
					return true;
				}
			}
			else {
				r = p;
				t = token_t::ab;
				return true;
			}
			return false;
		}
		else {
			r = p;
			t = token_t::a;
			return true;
		}
	}
	return false;
}
$ gen-func a ab abc abcd abc$'\''\xfa'\''
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a[b[c[dú|]]]
	if (*n ++ == '\''a'\'') {
		const char* p = n;
		if (*n ++ == '\''b'\'') {
			const char* p = n;
			if (*n ++ == '\''c'\'') {
				const char* p = n;
				switch (*n ++) {
				case '\''d'\'':
					r = n;
					t = token_t::abcd;
					return true;
				case '\''\xfa'\'':
					if (*n == 0) {
						return "abc\xfa";
					return false;
				default:
					r = p;
					t = token_t::abc;
					return true;
				}
			}
			else {
				r = p;
				t = token_t::ab;
				return true;
			}
		}
		else {
			r = p;
			t = token_t::a;
			return true;
		}
	}
	return false;
}
$ gen-func a ab abc abd ac
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a[b[c|d]|c]
	if (*n ++ == '\''a'\'') {
		const char* p = n;
		switch (*n ++) {
		case '\''b'\'': {
			const char* p = n;
			switch (*n ++) {
			case '\''c'\'':
				r = n;
				t = token_t::abc;
				return true;
			case '\''d'\'':
				r = n;
				t = token_t::abd;
				return true;
			default:
				r = p;
				t = token_t::ab;
				return true;
			}
		}
		case '\''c'\'':
			r = n;
			t = token_t::ac;
			return true;
		default:
			r = p;
			t = token_t::a;
			return true;
		}
	}
	return false;
}
$ gen-func a ab ac
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a[b|c]
	if (*n ++ == '\''a'\'') {
		const char* p = n;
		switch (*n ++) {
		case '\''b'\'':
			r = n;
			t = token_t::ab;
			return true;
		case '\''c'\'':
			r = n;
			t = token_t::ac;
			return true;
		default:
			r = p;
			t = token_t::a;
			return true;
		}
	}
	return false;
}
$ gen-func a ab ac acd
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a[b|c[d]]
	if (*n ++ == '\''a'\'') {
		const char* p = n;
		switch (*n ++) {
		case '\''b'\'':
			r = n;
			t = token_t::ab;
			return true;
		case '\''c'\'': {
			const char* p = n;
			if (*n ++ == '\''d'\'') {
				r = n;
				t = token_t::acd;
				return true;
			}
			else {
				r = p;
				t = token_t::ac;
				return true;
			}
		}
		default:
			r = p;
			t = token_t::a;
			return true;
		}
	}
	return false;
}
$ gen-func a ab ac ad
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a[b|c|d]
	if (*n ++ == '\''a'\'') {
		const char* p = n;
		switch (*n ++) {
		case '\''b'\'':
			r = n;
			t = token_t::ab;
			return true;
		case '\''c'\'':
			r = n;
			t = token_t::ac;
			return true;
		case '\''d'\'':
			r = n;
			t = token_t::ad;
			return true;
		default:
			r = p;
			t = token_t::a;
			return true;
		}
	}
	return false;
}
$ gen-func a abcd abcdefg abcdxyz h hijk
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a[bcd[efg|xyz]]|h[ijk]
	switch (*n ++) {
	case '\''a'\'': {
		const char* p = n;
		if (*n ++ == '\''b'\'' &&
			*n ++ == '\''c'\'' &&
			*n ++ == '\''d'\'') {
			const char* p = n;
			switch (*n ++) {
			case '\''e'\'':
				if (*n ++ == '\''f'\'' &&
					*n ++ == '\''g'\'') {
					r = n;
					t = token_t::abcdefg;
					return true;
				}
				return false;
			case '\''x'\'':
				if (*n ++ == '\''y'\'' &&
					*n ++ == '\''z'\'') {
					r = n;
					t = token_t::abcdxyz;
					return true;
				}
				return false;
			default:
				r = p;
				t = token_t::abcd;
				return true;
			}
		}
		else {
			r = p;
			t = token_t::a;
			return true;
		}
	}
	case '\''h'\'':
		const char* p = n;
		if (*n ++ == '\''i'\'' &&
			*n ++ == '\''j'\'' &&
			*n ++ == '\''k'\'') {
			r = n;
			t = token_t::hijk;
			return true;
		}
		else {
			r = p;
			t = token_t::h;
			return true;
		}
	}
	return false;
}
$ gen-func a abcd abcdefg abcdxyz h hijk hlm
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a[bcd[efg|xyz]]|h[ijk|lm]
	switch (*n ++) {
	case '\''a'\'': {
		const char* p = n;
		if (*n ++ == '\''b'\'' &&
			*n ++ == '\''c'\'' &&
			*n ++ == '\''d'\'') {
			const char* p = n;
			switch (*n ++) {
			case '\''e'\'':
				if (*n ++ == '\''f'\'' &&
					*n ++ == '\''g'\'') {
					r = n;
					t = token_t::abcdefg;
					return true;
				}
				return false;
			case '\''x'\'':
				if (*n ++ == '\''y'\'' &&
					*n ++ == '\''z'\'') {
					r = n;
					t = token_t::abcdxyz;
					return true;
				}
				return false;
			default:
				r = p;
				t = token_t::abcd;
				return true;
			}
		}
		else {
			r = p;
			t = token_t::a;
			return true;
		}
	}
	case '\''h'\'':
		const char* p = n;
		switch (*n ++) {
		case '\''i'\'':
			if (*n ++ == '\''j'\'' &&
				*n ++ == '\''k'\'') {
				r = n;
				t = token_t::hijk;
				return true;
			}
			return false;
		case '\''l'\'':
			if (*n ++ == '\''m'\'') {
				r = n;
				t = token_t::hlm;
				return true;
			}
			return false;
		default:
			r = p;
			t = token_t::h;
			return true;
		}
	}
	return false;
}
$ gen-func a abcd abcdefg h hijk
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a[bcd[efg]]|h[ijk]
	switch (*n ++) {
	case '\''a'\'': {
		const char* p = n;
		if (*n ++ == '\''b'\'' &&
			*n ++ == '\''c'\'' &&
			*n ++ == '\''d'\'') {
			const char* p = n;
			if (*n ++ == '\''e'\'' &&
				*n ++ == '\''f'\'' &&
				*n ++ == '\''g'\'') {
				r = n;
				t = token_t::abcdefg;
				return true;
			}
			else {
				r = p;
				t = token_t::abcd;
				return true;
			}
		}
		else {
			r = p;
			t = token_t::a;
			return true;
		}
		return false;
	}
	case '\''h'\'':
		const char* p = n;
		if (*n ++ == '\''i'\'' &&
			*n ++ == '\''j'\'' &&
			*n ++ == '\''k'\'') {
			r = n;
			t = token_t::hijk;
			return true;
		}
		else {
			r = p;
			t = token_t::h;
			return true;
		}
	}
	return false;
}
$ gen-func a abd ac
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a[bd|c]
	if (*n ++ == '\''a'\'') {
		const char* p = n;
		switch (*n ++) {
		case '\''b'\'':
			if (*n ++ == '\''d'\'') {
				r = n;
				t = token_t::abd;
				return true;
			}
			return false;
		case '\''c'\'':
			r = n;
			t = token_t::ac;
			return true;
		default:
			r = p;
			t = token_t::a;
			return true;
		}
	}
	return false;
}
$ gen-func a b
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a|b
	switch (*n ++) {
	case '\''a'\'':
		r = n;
		t = token_t::a;
		return true;
	case '\''b'\'':
		r = n;
		t = token_t::b;
		return true;
	}
	return false;
}
$ gen-func a b abc bac abd
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a[b(c|d)]|b[ac]
	switch (*n ++) {
	case '\''a'\'': {
		const char* p = n;
		if (*n ++ == '\''b'\'') {
			switch (*n ++) {
			case '\''c'\'':
				r = n;
				t = token_t::abc;
				return true;
			case '\''d'\'':
				r = n;
				t = token_t::abd;
				return true;
			}
			return false;
		}
		else {
			r = p;
			t = token_t::a;
			return true;
		}
	}
	case '\''b'\'':
		const char* p = n;
		if (*n ++ == '\''a'\'' &&
			*n ++ == '\''c'\'') {
			r = n;
			t = token_t::bac;
			return true;
		}
		else {
			r = p;
			t = token_t::b;
			return true;
		}
	}
	return false;
}
$ gen-func a b bb
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a|b[b]
	switch (*n ++) {
	case '\''a'\'':
		r = n;
		t = token_t::a;
		return true;
	case '\''b'\'':
		const char* p = n;
		if (*n ++ == '\''b'\'') {
			r = n;
			t = token_t::bb;
			return true;
		}
		else {
			r = p;
			t = token_t::b;
			return true;
		}
	}
	return false;
}
$ gen-func a b bb cc ccc ddd dddd
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a|b[b]|cc[c]|ddd[d]
	switch (*n ++) {
	case '\''a'\'':
		r = n;
		t = token_t::a;
		return true;
	case '\''b'\'': {
		const char* p = n;
		if (*n ++ == '\''b'\'') {
			r = n;
			t = token_t::bb;
			return true;
		}
		else {
			r = p;
			t = token_t::b;
			return true;
		}
	}
	case '\''c'\'':
		if (*n ++ == '\''c'\'') {
			const char* p = n;
			if (*n ++ == '\''c'\'') {
				r = n;
				t = token_t::ccc;
				return true;
			}
			else {
				r = p;
				t = token_t::cc;
				return true;
			}
		}
		return false;
	case '\''d'\'':
		if (*n ++ == '\''d'\'' &&
			*n ++ == '\''d'\'') {
			const char* p = n;
			if (*n ++ == '\''d'\'') {
				r = n;
				t = token_t::dddd;
				return true;
			}
			else {
				r = p;
				t = token_t::ddd;
				return true;
			}
		}
	}
	return false;
}
$ gen-func a b c
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a|b|c
	switch (*n ++) {
	case '\''a'\'':
		r = n;
		t = token_t::a;
		return true;
	case '\''b'\'':
		r = n;
		t = token_t::b;
		return true;
	case '\''c'\'':
		r = n;
		t = token_t::c;
		return true;
	}
	return false;
}
$ gen-func a bb ba c
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a|b(a|b)|c
	switch (*n ++) {
	case '\''a'\'':
		r = n;
		t = token_t::a;
		return true;
	case '\''b'\'':
		switch (*n ++) {
		case '\''a'\'':
			r = n;
			t = token_t::ba;
			return true;
		case '\''b'\'':
			r = n;
			t = token_t::bb;
			return true;
		}
		return false;
	case '\''c'\'':
		r = n;
		t = token_t::c;
		return true;
	}
	return false;
}
$ gen-func a bb ba cc
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a|b(a|b)|cc
	switch (*n ++) {
	case '\''a'\'':
		r = n;
		t = token_t::a;
		return true;
	case '\''b'\'':
		switch (*n ++) {
		case '\''a'\'':
			r = n;
			t = token_t::ba;
			return true;
		case '\''b'\'':
			r = n;
			t = token_t::bb;
			return true;
		}
		return false;
	case '\''c'\'':
		if (*n ++ == '\''c'\'') {
			r = n;
			t = token_t::cc;
			return true;
		}
	}
	return false;
}
$ gen-func a bb ba ccc
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a|b(a|b)|ccc
	switch (*n ++) {
	case '\''a'\'':
		r = n;
		t = token_t::a;
		return true;
	case '\''b'\'':
		switch (*n ++) {
		case '\''a'\'':
			r = n;
			t = token_t::ba;
			return true;
		case '\''b'\'':
			r = n;
			t = token_t::bb;
			return true;
		}
		return false;
	case '\''c'\'':
		if (*n ++ == '\''c'\'' &&
			*n ++ == '\''c'\'') {
			r = n;
			t = token_t::ccc;
			return true;
		}
	}
	return false;
}
$ gen-func a bb ba cde
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a|b(a|b)|cde
	switch (*n ++) {
	case '\''a'\'':
		r = n;
		t = token_t::a;
		return true;
	case '\''b'\'':
		switch (*n ++) {
		case '\''a'\'':
			r = n;
			t = token_t::ba;
			return true;
		case '\''b'\'':
			r = n;
			t = token_t::bb;
			return true;
		}
		return false;
	case '\''c'\'':
		if (*n ++ == '\''d'\'' &&
			*n ++ == '\''e'\'') {
			r = n;
			t = token_t::cde;
			return true;
		}
	}
	return false;
}
$ gen-func a bb ba cdef
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a|b(a|b)|cdef
	switch (*n ++) {
	case '\''a'\'':
		r = n;
		t = token_t::a;
		return true;
	case '\''b'\'':
		switch (*n ++) {
		case '\''a'\'':
			r = n;
			t = token_t::ba;
			return true;
		case '\''b'\'':
			r = n;
			t = token_t::bb;
			return true;
		}
		return false;
	case '\''c'\'':
		if (*n ++ == '\''d'\'' &&
			*n ++ == '\''e'\'' &&
			*n ++ == '\''f'\'') {
			r = n;
			t = token_t::cdef;
			return true;
		}
	}
	return false;
}
$ gen-func a bb ba cdef cdefg
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a|b(a|b)|cdef[g]
	switch (*n ++) {
	case '\''a'\'':
		r = n;
		t = token_t::a;
		return true;
	case '\''b'\'':
		switch (*n ++) {
		case '\''a'\'':
			r = n;
			t = token_t::ba;
			return true;
		case '\''b'\'':
			r = n;
			t = token_t::bb;
			return true;
		}
		return false;
	case '\''c'\'':
		if (*n ++ == '\''d'\'' &&
			*n ++ == '\''e'\'' &&
			*n ++ == '\''f'\'') {
			const char* p = n;
			if (*n ++ == '\''g'\'') {
				r = n;
				t = token_t::cdefg;
				return true;
			}
			else {
				r = p;
				t = token_t::cdef;
				return true;
			}
		}
	}
	return false;
}
$ gen-func a bb bac cdef
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a|b(ac|b)|cdef
	switch (*n ++) {
	case '\''a'\'':
		r = n;
		t = token_t::a;
		return true;
	case '\''b'\'':
		switch (*n ++) {
		case '\''a'\'':
			if (*n ++ == '\''c'\'') {
				r = n;
				t = token_t::bac;
				return true;
			}
			return false;
		case '\''b'\'':
			r = n;
			t = token_t::bb;
			return true;
		}
		return false;
	case '\''c'\'':
		if (*n ++ == '\''d'\'' &&
			*n ++ == '\''e'\'' &&
			*n ++ == '\''f'\'') {
			r = n;
			t = token_t::cdef;
			return true;
		}
	}
	return false;
}
$ gen-func a bb ccc
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a|bb|ccc
	switch (*n ++) {
	case '\''a'\'':
		r = n;
		t = token_t::a;
		return true;
	case '\''b'\'':
		if (*n ++ == '\''b'\'') {
			r = n;
			t = token_t::bb;
			return true;
		}
		return false;
	case '\''c'\'':
		if (*n ++ == '\''c'\'' &&
			*n ++ == '\''c'\'') {
			r = n;
			t = token_t::ccc;
			return true;
		}
	}
	return false;
}
$ gen-func a bbx ba ccc
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a|b(a|bx)|ccc
	switch (*n ++) {
	case '\''a'\'':
		r = n;
		t = token_t::a;
		return true;
	case '\''b'\'':
		switch (*n ++) {
		case '\''a'\'':
			r = n;
			t = token_t::ba;
			return true;
		case '\''b'\'':
			if (*n ++ == '\''x'\'') {
				r = n;
				t = token_t::bbx;
				return true;
			}
		}
		return false;
	case '\''c'\'':
		if (*n ++ == '\''c'\'' &&
			*n ++ == '\''c'\'') {
			r = n;
			t = token_t::ccc;
			return true;
		}
	}
	return false;
}
$ gen-func a bbx bay ccc
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a|b(ay|bx)|ccc
	switch (*n ++) {
	case '\''a'\'':
		r = n;
		t = token_t::a;
		return true;
	case '\''b'\'':
		switch (*n ++) {
		case '\''a'\'':
			if (*n ++ == '\''y'\'') {
				r = n;
				t = token_t::bay;
				return true;
			}
			return false;
		case '\''b'\'':
			if (*n ++ == '\''x'\'') {
				r = n;
				t = token_t::bbx;
				return true;
			}
		}
		return false;
	case '\''c'\'':
		if (*n ++ == '\''c'\'' &&
			*n ++ == '\''c'\'') {
			r = n;
			t = token_t::ccc;
			return true;
		}
	}
	return false;
}
$ gen-func a cde cdef
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a|cde[f]
	switch (*n ++) {
	case '\''a'\'':
		r = n;
		t = token_t::a;
		return true;
	case '\''c'\'':
		if (*n ++ == '\''d'\'' &&
			*n ++ == '\''e'\'') {
			const char* p = n;
			if (*n ++ == '\''f'\'') {
				r = n;
				t = token_t::cdef;
				return true;
			}
			else {
				r = p;
				t = token_t::cde;
				return true;
			}
		}
	}
	return false;
}
$ gen-func a cde cdef cdefg
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a|cde[f[g]]
	switch (*n ++) {
	case '\''a'\'':
		r = n;
		t = token_t::a;
		return true;
	case '\''c'\'':
		if (*n ++ == '\''d'\'' &&
			*n ++ == '\''e'\'') {
			const char* p = n;
			if (*n ++ == '\''f'\'') {
				const char* p = n;
				if (*n ++ == '\''g'\'') {
					r = n;
					t = token_t::cdefg;
					return true;
				}
				else {
					r = p;
					t = token_t::cdef;
					return true;
				}
			}
			else {
				r = p;
				t = token_t::cde;
				return true;
			}
		}
	}
	return false;
}
$ gen-func a cde cdef cdefgh
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a|cde[f[gh]]
	switch (*n ++) {
	case '\''a'\'':
		r = n;
		t = token_t::a;
		return true;
	case '\''c'\'':
		if (*n ++ == '\''d'\'' &&
			*n ++ == '\''e'\'') {
			const char* p = n;
			if (*n ++ == '\''f'\'') {
				const char* p = n;
				if (*n ++ == '\''g'\'' &&
					*n ++ == '\''h'\'') {
					r = n;
					t = token_t::cdefgh;
					return true;
				}
				else {
					r = p;
					t = token_t::cdef;
					return true;
				}
			}
			else {
				r = p;
				t = token_t::cde;
				return true;
			}
		}
	}
	return false;
}
$ gen-func a cdef cdefg
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a|cdef[g]
	switch (*n ++) {
	case '\''a'\'':
		r = n;
		t = token_t::a;
		return true;
	case '\''c'\'':
		if (*n ++ == '\''d'\'' &&
			*n ++ == '\''e'\'' &&
			*n ++ == '\''f'\'') {
			const char* p = n;
			if (*n ++ == '\''g'\'') {
				r = n;
				t = token_t::cdefg;
				return true;
			}
			else {
				r = p;
				t = token_t::cdef;
				return true;
			}
		}
	}
	return false;
}
$ gen-func aa bb
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: aa|bb
	switch (*n ++) {
	case '\''a'\'':
		if (*n ++ == '\''a'\'') {
			r = n;
			t = token_t::aa;
			return true;
		}
		return false;
	case '\''b'\'':
		if (*n ++ == '\''b'\'') {
			r = n;
			t = token_t::bb;
			return true;
		}
	}
	return false;
}
$ gen-func ab
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: ab
	if (*n ++ == '\''a'\'' &&
		*n ++ == '\''b'\'') {
		r = n;
		t = token_t::ab;
		return true;
	}
	return false;
}
$ gen-func ab bb ba ccc
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: ab|b(a|b)|ccc
	switch (*n ++) {
	case '\''a'\'':
		if (*n ++ == '\''b'\'') {
			r = n;
			t = token_t::ab;
			return true;
		}
		return false;
	case '\''b'\'':
		switch (*n ++) {
		case '\''a'\'':
			r = n;
			t = token_t::ba;
			return true;
		case '\''b'\'':
			r = n;
			t = token_t::bb;
			return true;
		}
		return false;
	case '\''c'\'':
		if (*n ++ == '\''c'\'' &&
			*n ++ == '\''c'\'') {
			r = n;
			t = token_t::ccc;
			return true;
		}
	}
	return false;
}
$ gen-func ab bb ba cde
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: ab|b(a|b)|cde
	switch (*n ++) {
	case '\''a'\'':
		if (*n ++ == '\''b'\'') {
			r = n;
			t = token_t::ab;
			return true;
		}
		return false;
	case '\''b'\'':
		switch (*n ++) {
		case '\''a'\'':
			r = n;
			t = token_t::ba;
			return true;
		case '\''b'\'':
			r = n;
			t = token_t::bb;
			return true;
		}
		return false;
	case '\''c'\'':
		if (*n ++ == '\''d'\'' &&
			*n ++ == '\''e'\'') {
			r = n;
			t = token_t::cde;
			return true;
		}
	}
	return false;
}
$ gen-func ab bbx ba ccc
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: ab|b(a|bx)|ccc
	switch (*n ++) {
	case '\''a'\'':
		if (*n ++ == '\''b'\'') {
			r = n;
			t = token_t::ab;
			return true;
		}
		return false;
	case '\''b'\'':
		switch (*n ++) {
		case '\''a'\'':
			r = n;
			t = token_t::ba;
			return true;
		case '\''b'\'':
			if (*n ++ == '\''x'\'') {
				r = n;
				t = token_t::bbx;
				return true;
			}
		}
		return false;
	case '\''c'\'':
		if (*n ++ == '\''c'\'' &&
			*n ++ == '\''c'\'') {
			r = n;
			t = token_t::ccc;
			return true;
		}
	}
	return false;
}
$ gen-func ab c
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: ab|c
	switch (*n ++) {
	case '\''a'\'':
		if (*n ++ == '\''b'\'') {
			r = n;
			t = token_t::ab;
			return true;
		}
		return false;
	case '\''c'\'':
		r = n;
		t = token_t::c;
		return true;
	}
	return false;
}
$ gen-func abc abd acde
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a(b(c|d)|cde)
	if (*n ++ == '\''a'\'') {
		switch (*n ++) {
		case '\''b'\'':
			switch (*n ++) {
			case '\''c'\'':
				r = n;
				t = token_t::abc;
				return true;
			case '\''d'\'':
				r = n;
				t = token_t::abd;
				return true;
			}
			return false;
		case '\''c'\'':
			if (*n ++ == '\''d'\'' &&
				*n ++ == '\''e'\'') {
				r = n;
				t = token_t::acde;
				return true;
			}
		}
	}
	return false;
}
$ gen-func abc abd acde ac
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a(b(c|d)|c[de])
	if (*n ++ == '\''a'\'') {
		switch (*n ++) {
		case '\''b'\'':
			switch (*n ++) {
			case '\''c'\'':
				r = n;
				t = token_t::abc;
				return true;
			case '\''d'\'':
				r = n;
				t = token_t::abd;
				return true;
			}
			return false;
		case '\''c'\'':
			const char* p = n;
			if (*n ++ == '\''d'\'' &&
				*n ++ == '\''e'\'') {
				r = n;
				t = token_t::acde;
				return true;
			}
			else {
				r = p;
				t = token_t::ac;
				return true;
			}
		}
	}
	return false;
}
$ gen-func abc abd acde acfg
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a(b(c|d)|c(de|fg))
	if (*n ++ == '\''a'\'') {
		switch (*n ++) {
		case '\''b'\'':
			switch (*n ++) {
			case '\''c'\'':
				r = n;
				t = token_t::abc;
				return true;
			case '\''d'\'':
				r = n;
				t = token_t::abd;
				return true;
			}
			return false;
		case '\''c'\'':
			switch (*n ++) {
			case '\''d'\'':
				if (*n ++ == '\''e'\'') {
					r = n;
					t = token_t::acde;
					return true;
				}
				return false;
			case '\''f'\'':
				if (*n ++ == '\''g'\'') {
					r = n;
					t = token_t::acfg;
					return true;
				}
			}
		}
	}
	return false;
}
$ gen-func abc bb ba ccc
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: abc|b(a|b)|ccc
	switch (*n ++) {
	case '\''a'\'':
		if (*n ++ == '\''b'\'' &&
			*n ++ == '\''c'\'') {
			r = n;
			t = token_t::abc;
			return true;
		}
		return false;
	case '\''b'\'':
		switch (*n ++) {
		case '\''a'\'':
			r = n;
			t = token_t::ba;
			return true;
		case '\''b'\'':
			r = n;
			t = token_t::bb;
			return true;
		}
		return false;
	case '\''c'\'':
		if (*n ++ == '\''c'\'' &&
			*n ++ == '\''c'\'') {
			r = n;
			t = token_t::ccc;
			return true;
		}
	}
	return false;
}
$ gen-func abcd abde abef
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: ab(cd|de|ef)
	if (*n ++ == '\''a'\'' &&
		*n ++ == '\''b'\'') {
		switch (*n ++) {
		case '\''c'\'':
			if (*n ++ == '\''d'\'') {
				r = n;
				t = token_t::abcd;
				return true;
			}
			return false;
		case '\''d'\'':
			if (*n ++ == '\''e'\'') {
				r = n;
				t = token_t::abde;
				return true;
			}
			return false;
		case '\''e'\'':
			if (*n ++ == '\''f'\'') {
				r = n;
				t = token_t::abef;
				return true;
			}
		}
	}
	return false;
}
$ gen-func ac ab
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: a(b|c)
	if (*n ++ == '\''a'\'') {
		switch (*n ++) {
		case '\''b'\'':
			r = n;
			t = token_t::ab;
			return true;
		case '\''c'\'':
			r = n;
			t = token_t::ac;
			return true;
		}
	}
	return false;
}
$ gen-func cde cdef cdefgh
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: cde[f[gh]]
	if (*n ++ == '\''c'\'' &&
		*n ++ == '\''d'\'' &&
		*n ++ == '\''e'\'') {
		const char* p = n;
		if (*n ++ == '\''f'\'') {
			const char* p = n;
			if (*n ++ == '\''g'\'' &&
				*n ++ == '\''h'\'') {
				r = n;
				t = token_t::cdefgh;
				return true;
			}
			else {
				r = p;
				t = token_t::cdef;
				return true;
			}
		}
		else {
			r = p;
			t = token_t::cde;
			return true;
		}
	}
	return false;
}
$ gen-func cde cfg cfgx cfgxy cfgxyz cfgxzzz
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: c(de|fg[x[y[z]|zzz]])
	if (*n ++ == '\''c'\'') {
		switch (*n ++) {
		case '\''d'\'':
			if (*n ++ == '\''e'\'') {
				r = n;
				t = token_t::cde;
				return true;
			}
			return false;
		case '\''f'\'':
			if (*n ++ == '\''g'\'') {
				const char* p = n;
				if (*n ++ == '\''x'\'') {
					const char* p = n;
					switch (*n ++) {
					case '\''y'\'': {
						const char* p = n;
						if (*n ++ == '\''z'\'') {
							r = n;
							t = token_t::cfgxyz;
							return true;
						}
						else {
							r = p;
							t = token_t::cfgxy;
							return true;
						}
					}
					case '\''z'\'':
						if (*n ++ == '\''z'\'' &&
							*n ++ == '\''z'\'') {
							r = n;
							t = token_t::cfgxzzz;
							return true;
						}
						return false;
					default:
						r = p;
						t = token_t::cfgx;
						return true;
					}
				}
				else {
					r = p;
					t = token_t::cfg;
					return true;
				}
			}
		}
	}
	return false;
}
$ gen-func cdef cdefg
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: cdef[g]
	if (*n ++ == '\''c'\'' &&
		*n ++ == '\''d'\'' &&
		*n ++ == '\''e'\'' &&
		*n ++ == '\''f'\'') {
		const char* p = n;
		if (*n ++ == '\''g'\'') {
			r = n;
			t = token_t::cdefg;
			return true;
		}
		else {
			r = p;
			t = token_t::cdef;
			return true;
		}
	}
	return false;
}
$ gen-func cdex cdfy cdgz cdhw
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: cd(ex|fy|gz|hw)
	if (*n ++ == '\''c'\'' &&
		*n ++ == '\''d'\'') {
		switch (*n ++) {
		case '\''e'\'':
			if (*n ++ == '\''x'\'') {
				r = n;
				t = token_t::cdex;
				return true;
			}
			return false;
		case '\''f'\'':
			if (*n ++ == '\''y'\'') {
				r = n;
				t = token_t::cdfy;
				return true;
			}
			return false;
		case '\''g'\'':
			if (*n ++ == '\''z'\'') {
				r = n;
				t = token_t::cdgz;
				return true;
			}
			return false;
		case '\''h'\'':
			if (*n ++ == '\''w'\'') {
				r = n;
				t = token_t::cdhw;
				return true;
			}
		}
	}
	return false;
}
$ gen-func ce cdex cdfy cdgz cdhw
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: c(d(ex|fy|gz|hw)|e)
	if (*n ++ == '\''c'\'') {
		switch (*n ++) {
		case '\''d'\'':
			switch (*n ++) {
			case '\''e'\'':
				if (*n ++ == '\''x'\'') {
					r = n;
					t = token_t::cdex;
					return true;
				}
				return false;
			case '\''f'\'':
				if (*n ++ == '\''y'\'') {
					r = n;
					t = token_t::cdfy;
					return true;
				}
				return false;
			case '\''g'\'':
				if (*n ++ == '\''z'\'') {
					r = n;
					t = token_t::cdgz;
					return true;
				}
				return false;
			case '\''h'\'':
				if (*n ++ == '\''w'\'') {
					r = n;
					t = token_t::cdhw;
					return true;
				}
			}
			return false;
		case '\''e'\'':
			r = n;
			t = token_t::ce;
			return true;
		}
	}
	return false;
}
$ gen-func cge cfg cfgx cfgxy cfgxyz cfgxzzz
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: c(fg[x[y[z]|zzz]]|ge)
	if (*n ++ == '\''c'\'') {
		switch (*n ++) {
		case '\''f'\'':
			if (*n ++ == '\''g'\'') {
				const char* p = n;
				if (*n ++ == '\''x'\'') {
					const char* p = n;
					switch (*n ++) {
					case '\''y'\'': {
						const char* p = n;
						if (*n ++ == '\''z'\'') {
							r = n;
							t = token_t::cfgxyz;
							return true;
						}
						else {
							r = p;
							t = token_t::cfgxy;
							return true;
						}
					}
					case '\''z'\'':
						if (*n ++ == '\''z'\'' &&
							*n ++ == '\''z'\'') {
							r = n;
							t = token_t::cfgxzzz;
							return true;
						}
						return false;
					default:
						r = p;
						t = token_t::cfgx;
						return true;
					}
				}
				else {
					r = p;
					t = token_t::cfg;
					return true;
				}
			}
			return false;
		case '\''g'\'':
			if (*n ++ == '\''e'\'') {
				r = n;
				t = token_t::cge;
				return true;
			}
		}
	}
	return false;
}
$ gen-func pot potato pottery tattoo tempo
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: pot[ato|tery]|t(attoo|empo)
	switch (*n ++) {
	case '\''p'\'':
		if (*n ++ == '\''o'\'' &&
			*n ++ == '\''t'\'') {
			const char* p = n;
			switch (*n ++) {
			case '\''a'\'':
				if (*n ++ == '\''t'\'' &&
					*n ++ == '\''o'\'') {
					r = n;
					t = token_t::potato;
					return true;
				}
				return false;
			case '\''t'\'':
				if (*n ++ == '\''e'\'' &&
					*n ++ == '\''r'\'' &&
					*n ++ == '\''y'\'') {
					r = n;
					t = token_t::pottery;
					return true;
				}
				return false;
			default:
				r = p;
				t = token_t::pot;
				return true;
			}
		}
		return false;
	case '\''t'\'':
		switch (*n ++) {
		case '\''a'\'':
			if (*n ++ == '\''t'\'' &&
				*n ++ == '\''t'\'' &&
				*n ++ == '\''o'\'' &&
				*n ++ == '\''o'\'') {
				r = n;
				t = token_t::tattoo;
				return true;
			}
			return false;
		case '\''e'\'':
			if (*n ++ == '\''m'\'' &&
				*n ++ == '\''p'\'' &&
				*n ++ == '\''o'\'') {
				r = n;
				t = token_t::tempo;
				return true;
			}
		}
	}
	return false;
}
$ gen-func test
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: test
	if (*n ++ == '\''t'\'' &&
		*n ++ == '\''e'\'' &&
		*n ++ == '\''s'\'' &&
		*n ++ == '\''t'\'') {
		r = n;
		t = token_t::test;
		return true;
	}
	return false;
}
$ gen-func test tests
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: test[s]
	if (*n ++ == '\''t'\'' &&
		*n ++ == '\''e'\'' &&
		*n ++ == '\''s'\'' &&
		*n ++ == '\''t'\'') {
		const char* p = n;
		if (*n ++ == '\''s'\'') {
			r = n;
			t = token_t::tests;
			return true;
		}
		else {
			r = p;
			t = token_t::test;
			return true;
		}
	}
	return false;
}
$ gen-func test-str test-string test-int test-float
bool Parser::lookup_token(const char* n, token_t::type_t& t, const char*& r)
{
	// pattern: test-(float|int|str[ing])
	if (*n ++ == '\''t'\'' &&
		*n ++ == '\''e'\'' &&
		*n ++ == '\''s'\'' &&
		*n ++ == '\''t'\'' &&
		*n ++ == '\''-'\'') {
		switch (*n ++) {
		case '\''f'\'':
			if (*n ++ == '\''l'\'' &&
				*n ++ == '\''o'\'' &&
				*n ++ == '\''a'\'' &&
				*n ++ == '\''t'\'') {
				r = n;
				t = token_t::test-float;
				return true;
			}
			return false;
		case '\''i'\'':
			if (*n ++ == '\''n'\'' &&
				*n ++ == '\''t'\'') {
				r = n;
				t = token_t::test-int;
				return true;
			}
			return false;
		case '\''s'\'':
			if (*n ++ == '\''t'\'' &&
				*n ++ == '\''r'\'') {
				const char* p = n;
				if (*n ++ == '\''i'\'' &&
					*n ++ == '\''n'\'' &&
					*n ++ == '\''g'\'') {
					r = n;
					t = token_t::test-string;
					return true;
				}
				else {
					r = p;
					t = token_t::test-str;
					return true;
				}
			}
		}
	}
	return false;
}'
) -L gen-func-ex.new <(
echo '$ test -x ./calc'
test -x ./calc 2>&1 ||
echo 'command failed: test -x ./calc'

echo '$ shopt -s extglob'
shopt -s extglob 2>&1 ||
echo 'command failed: shopt -s extglob'

echo '$ . ../src/commands.sh'
. ../src/commands.sh 2>&1 ||
echo 'command failed: . ../src/commands.sh'

echo '$ gen-func() { printf '\''%s\n'\'' "$@"|calc-gen-func; }'
gen-func() { printf '%s\n' "$@"|calc-gen-func; } 2>&1 ||
echo 'command failed: gen-func() { printf '\''%s\n'\'' "$@"|calc-gen-func; }'

echo '$ gen-func a'
gen-func a 2>&1 ||
echo 'command failed: gen-func a'

echo '$ gen-func a a'
gen-func a a 2>&1 ||
echo 'command failed: gen-func a a'

echo '$ gen-func a aa b'
gen-func a aa b 2>&1 ||
echo 'command failed: gen-func a aa b'

echo '$ gen-func a ab'
gen-func a ab 2>&1 ||
echo 'command failed: gen-func a ab'

echo '$ gen-func a ab abc'
gen-func a ab abc 2>&1 ||
echo 'command failed: gen-func a ab abc'

echo '$ gen-func a ab abc abcd'
gen-func a ab abc abcd 2>&1 ||
echo 'command failed: gen-func a ab abc abcd'

echo '$ gen-func a ab abc abcd abc$'\''\xfa'\'''
gen-func a ab abc abcd abc$'\xfa' 2>&1 ||
echo 'command failed: gen-func a ab abc abcd abc$'\''\xfa'\'''

echo '$ gen-func a ab abc abd ac'
gen-func a ab abc abd ac 2>&1 ||
echo 'command failed: gen-func a ab abc abd ac'

echo '$ gen-func a ab ac'
gen-func a ab ac 2>&1 ||
echo 'command failed: gen-func a ab ac'

echo '$ gen-func a ab ac acd'
gen-func a ab ac acd 2>&1 ||
echo 'command failed: gen-func a ab ac acd'

echo '$ gen-func a ab ac ad'
gen-func a ab ac ad 2>&1 ||
echo 'command failed: gen-func a ab ac ad'

echo '$ gen-func a abcd abcdefg abcdxyz h hijk'
gen-func a abcd abcdefg abcdxyz h hijk 2>&1 ||
echo 'command failed: gen-func a abcd abcdefg abcdxyz h hijk'

echo '$ gen-func a abcd abcdefg abcdxyz h hijk hlm'
gen-func a abcd abcdefg abcdxyz h hijk hlm 2>&1 ||
echo 'command failed: gen-func a abcd abcdefg abcdxyz h hijk hlm'

echo '$ gen-func a abcd abcdefg h hijk'
gen-func a abcd abcdefg h hijk 2>&1 ||
echo 'command failed: gen-func a abcd abcdefg h hijk'

echo '$ gen-func a abd ac'
gen-func a abd ac 2>&1 ||
echo 'command failed: gen-func a abd ac'

echo '$ gen-func a b'
gen-func a b 2>&1 ||
echo 'command failed: gen-func a b'

echo '$ gen-func a b abc bac abd'
gen-func a b abc bac abd 2>&1 ||
echo 'command failed: gen-func a b abc bac abd'

echo '$ gen-func a b bb'
gen-func a b bb 2>&1 ||
echo 'command failed: gen-func a b bb'

echo '$ gen-func a b bb cc ccc ddd dddd'
gen-func a b bb cc ccc ddd dddd 2>&1 ||
echo 'command failed: gen-func a b bb cc ccc ddd dddd'

echo '$ gen-func a b c'
gen-func a b c 2>&1 ||
echo 'command failed: gen-func a b c'

echo '$ gen-func a bb ba c'
gen-func a bb ba c 2>&1 ||
echo 'command failed: gen-func a bb ba c'

echo '$ gen-func a bb ba cc'
gen-func a bb ba cc 2>&1 ||
echo 'command failed: gen-func a bb ba cc'

echo '$ gen-func a bb ba ccc'
gen-func a bb ba ccc 2>&1 ||
echo 'command failed: gen-func a bb ba ccc'

echo '$ gen-func a bb ba cde'
gen-func a bb ba cde 2>&1 ||
echo 'command failed: gen-func a bb ba cde'

echo '$ gen-func a bb ba cdef'
gen-func a bb ba cdef 2>&1 ||
echo 'command failed: gen-func a bb ba cdef'

echo '$ gen-func a bb ba cdef cdefg'
gen-func a bb ba cdef cdefg 2>&1 ||
echo 'command failed: gen-func a bb ba cdef cdefg'

echo '$ gen-func a bb bac cdef'
gen-func a bb bac cdef 2>&1 ||
echo 'command failed: gen-func a bb bac cdef'

echo '$ gen-func a bb ccc'
gen-func a bb ccc 2>&1 ||
echo 'command failed: gen-func a bb ccc'

echo '$ gen-func a bbx ba ccc'
gen-func a bbx ba ccc 2>&1 ||
echo 'command failed: gen-func a bbx ba ccc'

echo '$ gen-func a bbx bay ccc'
gen-func a bbx bay ccc 2>&1 ||
echo 'command failed: gen-func a bbx bay ccc'

echo '$ gen-func a cde cdef'
gen-func a cde cdef 2>&1 ||
echo 'command failed: gen-func a cde cdef'

echo '$ gen-func a cde cdef cdefg'
gen-func a cde cdef cdefg 2>&1 ||
echo 'command failed: gen-func a cde cdef cdefg'

echo '$ gen-func a cde cdef cdefgh'
gen-func a cde cdef cdefgh 2>&1 ||
echo 'command failed: gen-func a cde cdef cdefgh'

echo '$ gen-func a cdef cdefg'
gen-func a cdef cdefg 2>&1 ||
echo 'command failed: gen-func a cdef cdefg'

echo '$ gen-func aa bb'
gen-func aa bb 2>&1 ||
echo 'command failed: gen-func aa bb'

echo '$ gen-func ab'
gen-func ab 2>&1 ||
echo 'command failed: gen-func ab'

echo '$ gen-func ab bb ba ccc'
gen-func ab bb ba ccc 2>&1 ||
echo 'command failed: gen-func ab bb ba ccc'

echo '$ gen-func ab bb ba cde'
gen-func ab bb ba cde 2>&1 ||
echo 'command failed: gen-func ab bb ba cde'

echo '$ gen-func ab bbx ba ccc'
gen-func ab bbx ba ccc 2>&1 ||
echo 'command failed: gen-func ab bbx ba ccc'

echo '$ gen-func ab c'
gen-func ab c 2>&1 ||
echo 'command failed: gen-func ab c'

echo '$ gen-func abc abd acde'
gen-func abc abd acde 2>&1 ||
echo 'command failed: gen-func abc abd acde'

echo '$ gen-func abc abd acde ac'
gen-func abc abd acde ac 2>&1 ||
echo 'command failed: gen-func abc abd acde ac'

echo '$ gen-func abc abd acde acfg'
gen-func abc abd acde acfg 2>&1 ||
echo 'command failed: gen-func abc abd acde acfg'

echo '$ gen-func abc bb ba ccc'
gen-func abc bb ba ccc 2>&1 ||
echo 'command failed: gen-func abc bb ba ccc'

echo '$ gen-func abcd abde abef'
gen-func abcd abde abef 2>&1 ||
echo 'command failed: gen-func abcd abde abef'

echo '$ gen-func ac ab'
gen-func ac ab 2>&1 ||
echo 'command failed: gen-func ac ab'

echo '$ gen-func cde cdef cdefgh'
gen-func cde cdef cdefgh 2>&1 ||
echo 'command failed: gen-func cde cdef cdefgh'

echo '$ gen-func cde cfg cfgx cfgxy cfgxyz cfgxzzz'
gen-func cde cfg cfgx cfgxy cfgxyz cfgxzzz 2>&1 ||
echo 'command failed: gen-func cde cfg cfgx cfgxy cfgxyz cfgxzzz'

echo '$ gen-func cdef cdefg'
gen-func cdef cdefg 2>&1 ||
echo 'command failed: gen-func cdef cdefg'

echo '$ gen-func cdex cdfy cdgz cdhw'
gen-func cdex cdfy cdgz cdhw 2>&1 ||
echo 'command failed: gen-func cdex cdfy cdgz cdhw'

echo '$ gen-func ce cdex cdfy cdgz cdhw'
gen-func ce cdex cdfy cdgz cdhw 2>&1 ||
echo 'command failed: gen-func ce cdex cdfy cdgz cdhw'

echo '$ gen-func cge cfg cfgx cfgxy cfgxyz cfgxzzz'
gen-func cge cfg cfgx cfgxy cfgxyz cfgxzzz 2>&1 ||
echo 'command failed: gen-func cge cfg cfgx cfgxy cfgxyz cfgxzzz'

echo '$ gen-func pot potato pottery tattoo tempo'
gen-func pot potato pottery tattoo tempo 2>&1 ||
echo 'command failed: gen-func pot potato pottery tattoo tempo'

echo '$ gen-func test'
gen-func test 2>&1 ||
echo 'command failed: gen-func test'

echo '$ gen-func test tests'
gen-func test tests 2>&1 ||
echo 'command failed: gen-func test tests'

echo '$ gen-func test-str test-string test-int test-float'
gen-func test-str test-string test-int test-float 2>&1 ||
echo 'command failed: gen-func test-str test-string test-int test-float'
)

